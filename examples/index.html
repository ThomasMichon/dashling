<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="X-UA-Compatible" content="IE=edge" />
    <meta charset="utf-8"/>
    <title>Dashling.js Test</title>
    <meta name="description" content="" />

    <script type="text/javascript" src="../dist/dashling.full.js"></script>

    <link rel="stylesheet" type="text/css" href="DashMonitor.css"></link>
    <script type="text/javascript" src="DashMonitor.js"></script>

    <script>
        var monitor,
            dashling;

        function initPage() {
            var videoElement = document.querySelector("video");

            videoElement.addEventListener("error", function(ev) { alert("Video element threw: " + ev); });
        }

        function loadDashling() {
            dashling = new Dashling();

            var qualitySelect = document.querySelector("#qualitySelect");
            var startingQuality = Number(qualitySelect.options[qualitySelect.selectedIndex].value);

            var useABR = document.querySelector("#autoAdjust").checked;

            var selection = document.querySelector("#videoSelect");
            var url = selection.options[selection.selectedIndex].value;

            dashling.settings.targetQuality.video = startingQuality;
            dashling.settings.isABREnabled = useABR;

            dashling.load(document.querySelector("video"), url);
            initMonitor();
        }

        function initMonitor() {
            monitor = new DashMonitor();
            document.getElementById("monitorContainer").innerHTML = monitor.renderHtml();
            monitor.activate();
            monitor.observeVideoElement(document.querySelector("video"));
            setInterval(updateMonitor, 200);
        }

        function updateMonitor() {
            monitor.setDataContext(getStatsFromDashling(dashling));
        }

        function getStatsFromDashling(player) {
            var context = {};
            var controller = player._streamController;
            var manifest = player.settings.manifest;

            if (manifest && controller) {
                var fragmentList = [ controller._streams[0].fragments, controller._streams[1].fragments];
                var qualityDictionary = {};

                context.videoDuration = manifest.mediaDuration;
                context.qualities = [];

                for (var fragmentListIndex = 0 ; fragmentListIndex< fragmentList.length; fragmentListIndex++) {
                    var fragments = fragmentList[fragmentListIndex];

                    for (var fragmentIndex = 0; fragmentIndex < fragments.length; fragmentIndex++) {
                        var fragment = fragments[fragmentIndex];

                        for (var requestIndex = 0; requestIndex < fragment.requests.length; requestIndex++) {
                            var fragmentRequest = fragment.requests[requestIndex];

                            var qualityEntry = qualityDictionary[fragmentRequest.qualityId];

                            if (!qualityEntry) {
                                qualityEntry = qualityDictionary[fragmentRequest.qualityId] = {
                                    name: fragmentRequest.qualityId,
                                    requests: []
                                };

                                context.qualities.push(qualityEntry);
                            }


                            var stateStrings = [""];
                            var stat = {
                                state: _findInEnum(fragment.state, Dashling.FragmentState),
                                segmentPosition: fragment.time.startSeconds,
                                segmentDuration: fragment.time.lengthSeconds,
                                requestIndex: requestIndex
                            };

                            qualityEntry.requests.push(stat);
                        }
                    }
                }
            }

            return context;
        }

        function _findInEnum(val, en) {
            for (var i in en) {
                if (en[i] == val) {
                    return i;
                }
            }
            return "";
        }

        function toggleBenefits() {
            var benefits = document.getElementById("benefits");
            benefits.className = benefits.className == "hidden" ? "" : "hidden";
        }

    </script>

    <style>
        body {
            font-family: Segoe UI;
            font-size: 12px;
            margin: 0;
            padding: 0;
        }
        h1 {
            font-family: Segoe UI Light;
            font-weight: lighter;
            font-size: 20px;

            margin: 0;
            padding: 5px 10px;
            margin-bottom: 5px;
            background: #727272;
            color: white;

            line-height: 35px;
            height: 40px;
        }
        h2 {
            font-weight: bold;
        }

        input {
            vertical-align: middle;
            margin: 0 5px 2px 0;

        }

        .content {
            padding: 5px 10px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body onload="initPage()">
    <div>
        <h1>Dashling Test Page</h1>
        <div class="content">
            <p>
                Dashling is a <b>Dynamic Adaptive Streaming over HTTP</b> (DASH) implementation. It downloads media fragments and pushes them into media buffers
                provided by the browsers <b>Media Source Extension</b> support. As latency is more understood and buffer availability changes, quality is adjusted appropriately.
                <a href="#" onclick="toggleBenefits()">See benefits over dash.js.</a>
            </p>
            <div id="benefits" class="hidden">
                <h2>Benefits over dash.js:</h2>
                <ul>
                    <li>No scheduler, which causes delays in between requests.</li>
                    <li>No nasty dupe fragment download bugs.</li>
                    <li>Retries with better delays. (500, 1500ms in between.)</li>
                    <li>Audio/video fragments are appended to MSE as a pair only when both are available, avoiding undefined browser behaviors.</li>
                    <li>No init fragments are requested if they're not needed.</li>
                    <li>No requests are canceled unnecessarily, only on seeking.</li>
                    <li>On seeks that require downloading new content, pending requests are canceled.</li>
                    <li>Can specify a default current position on startup, allowing for "reboots" if necessary, as well as sending "position" hyperlinks.</li>
                    <li>Quality rules are much more predictable: if you don't have enough buffer, we will be more conservative about quality. As your buffer amount grows, we increase quality. We can also do things like "avoid quality changes for X number of fragments."</li>
                    <li>Supports avoiding manifest request by default, if you have alternative means to provide necessary data.
                    Smaller code, avoids things we don't need to support.</li>
                </ul>
            </div>

            <select id="videoSelect">
                <option value="iosbug/manifest.xml">IOS bug video</option>
            </select>

            <div>
                <span>Starting video quality:</span>
                <select id="qualitySelect">
                    <option value="4" selected="selected">4</option>
                    <option value="3">3</option>
                    <option value="2">2</option>
                    <option value="1">1</option>
                    <option value="0">0</option>
                </select>

                <div><input id="autoAdjust" type="checkbox" checked></input><span>Auto adjust quality</span></div>
                <button type="button" onclick="loadDashling()">Load video</button>
            </div>
        </div>

        <video controls autoplay width="640" height="480"></video>
        <div id="monitorContainer" style="width: 640px;"></div>
    </div>
</body>
</html>
