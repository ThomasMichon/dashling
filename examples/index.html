<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="X-UA-Compatible" content="IE=edge" />
    <meta charset="utf-8"/>
    <title>Dashling.js Test</title>
    <meta name="description" content="" />
    
    <script type="text/javascript" src="../dist/dashling.min.js"></script>
    
    <link rel="stylesheet" type="text/css" href="DashMonitor.css"></link>
    <script type="text/javascript" src="DashMonitor.js"></script>

    <script>
        var monitor, 
            dashling;

        function initPage() {
            var videoElement = document.querySelector("video");

            videoElement.addEventListener("error", function(ev) { alert("Video element threw: " + ev); });
        }

        function loadDashling() {            
            dashling = new Dashling();

            var qualitySelect = document.querySelector("#qualitySelect");
            var startingQuality = Number(qualitySelect.options[qualitySelect.selectedIndex].value);
            
            var useABR = document.querySelector("#autoAdjust").checked;

            var selection = document.querySelector("#videoSelect");
            var url = selection.options[selection.selectedIndex].value;

            dashling.settings.targetVideoQuality = startingQuality;
            dashling.settings.isABREnabled = useABR;

            dashling.load(document.querySelector("video"), url);
            initMonitor();
        }

        function initMonitor() {
            monitor = new DashMonitor();
            document.getElementById("monitorContainer").innerHTML = monitor.renderHtml();
            monitor.activate();     
            monitor.observeVideoElement(document.querySelector("video"));            
            setInterval(updateMonitor, 200);
        }

        function updateMonitor() {
            monitor.setDataContext(getStatsFromDashling(dashling));
        }

        function getStatsFromDashling(player) {
            var context = {};
            var manifest = player._manifest;

            if (manifest && player._audioStream && player._videoStream) {
                var streamMaps = [ player._audioStream._streamMap, player._videoStream._streamMap];
                var qualityDictionary = {};

                context.videoDuration = manifest.mediaDuration;
                context.qualities = [];

                for (var streamIndex = 0 ; streamIndex< streamMaps.length; streamIndex++) {
                    var streamMap = streamMaps[streamIndex];

                    for (var segmentIndex = 0; segmentIndex < streamMap.length; segmentIndex++) {
                        var segment = streamMap[segmentIndex];

                        for (var requestIndex = 0; requestIndex < segment.requests.length; requestIndex++) {
                            var segmentRequest = segment.requests[requestIndex];

                            var qualityEntry = qualityDictionary[segmentRequest.qualityId];

                            if (!qualityEntry) {
                                qualityEntry = qualityDictionary[segmentRequest.qualityId] = {
                                    name: segmentRequest.qualityId,
                                    requests: []
                                };

                                context.qualities.push(qualityEntry);
                            }

                            var stat = {
                                state: segmentRequest.state,
                                segmentPosition: segment.time.startSeconds,
                                segmentDuration: segment.time.lengthSeconds,
                                requentIndex: requestIndex
                            };

                            qualityEntry.requests.push(stat);
                        }
                    }
                }
            }

            return context;
        }

        function toggleBenefits() {
            var benefits = document.getElementById("benefits");
            benefits.className = benefits.className == "hidden" ? "" : "hidden";
        }

    </script>
    
    <style>
        body {
            font-family: Segoe UI;
            font-size: 12px;
            margin: 0;
            padding: 0;
        }
        h1 {
            font-family: Segoe UI Light;
            font-weight: lighter;
            font-size: 20px;
            
            margin: 0;
            padding: 5px 10px;           
            margin-bottom: 5px;
            background: #eee;
        }
        h2 {
            font-weight: bold;
        }

        input {
            vertical-align: middle;
            margin: 0 5px 2px 0;
            
        }

        .content {
            padding: 5px 10px;           
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>

<body onload="initPage()">
    <div>
        <h1>Dashling Test Page</h1>
        <div class="content">
            <p>
                Dashling is a <b>Dynamic Adaptive Streaming over HTTP</b> (DASH) implementation. It downloads media fragments and pushes them into media buffers
                provided by the browsers <b>Media Source Extension</b> support. As latency is more understood and buffer availability changes, quality is adjusted appropriately.
                <a href="#" onclick="toggleBenefits()">See benefits over dash.js.</a>
            </p>
            <div id="benefits" class="hidden">
                <h2>Benefits over dash.js:</h2>
                <ul>
                    <li>No scheduler, which causes delays in between requests.</li>
                    <li>No nasty dupe segment download bugs.</li>
                    <li>Retries with better delays. (500, 1500ms in between.)</li>
                    <li>Audio/video fragments are appended to MSE as a pair only when both are available, avoiding undefined browser behaviors.</li>
                    <li>No init segments are requested if they're not needed.</li>
                    <li>No requests are canceled unnecessarily, only on seeking.</li>
                    <li>On seeks that require downloading new content, pending requests are canceled.</li>
                    <li>Can specify a default current position on startup, allowing for "reboots" if necessary, as well as sending "position" hyperlinks.</li>
                    <li>Quality rules are much more predictable: if you don't have enough buffer, we will be more conservative about quality. As your buffer amount grows, we increase quality. We can also do things like "avoid quality changes for X number of segments."</li>
                    <li>Supports avoiding manifest request by default, if you have alternative means to provide necessary data.
                    Smaller code, avoids things we don't need to support.</li>
                </ul>
            </div>              
            
            <select id="videoSelect">
                <option value="iosbug/manifest.xml">IOS bug video</option>
            </select>

            <div>
                <span>Starting video quality:</span>
                <select id="qualitySelect">
                    <option value="4">4</option>
                    <option value="3">3</option>
                    <option value="2" selected="selected">2</option>
                    <option value="1">1</option>
                    <option value="0">0</option>
                </select>

                <div><input id="autoAdjust" type="checkbox" checked></input><span>Auto adjust quality</span></div>
                <button type="button" onclick="loadDashling()">Load video</button>
            </div>
        </div>

        <video controls autoplay width="640" height="480"></video>
        <div id="monitorContainer" style="width: 640px;"></div>
    </div>
</body>
</html>
